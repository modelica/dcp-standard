== Transport Protocols

---

=== General
This section specifies the underlying transport protocols for DCP. Furthermore, this section assumes the default DCP slave integration as given in Figure 34. Therefore, the DCP integrator must know transport protocol specific information to connect the provided DCP slaves to a communication medium. For this step, the DCP slave description file may be helpful.

---

=== Internet Protocol (IPv4) Based Protocols

---

==== General
A DCP slave using IPv4-based transport protocols is accessible through an IP address and a port number. This information is defined within the DCP slave description. For communication with a DCP master, the DCP slave replies to the IP address and port where the initial +STC_register+ is coming from.

  Note: A DCP master could be implemented as a IPv4-based client, whereas a DCP slave could be implemented as a IPv4-based server.

As soon as +STC_register+ is received and positively acknowledged (+RSP_ack+ sent by DCP slave and received by DCP master) the IP address and port for communication with the master are fixed for this simulation run.

The port information at the slave side is cleared, as soon as +STC_deregister+ is received.

  Note: The DCP slave sender port may differ from the DCP slave receiving port.

---

===== Transport Protocol Specific Fields
The field port specifies an IPv4 port number. +
The field +ip_address+ specifies an internet protocol address.

---

===== Network Information

The master distributes the communication information relevant for data exchange using the following two PDUs: +CFG_target_network_information+ is sent to the sending DCP slave. It contains IP address and port number of the receiving DCP slave.

  Implementation hint: If multiple network information with the same data_id is received by a DCP slave, the DAT_input_output PDU is to be sent to all specified targets within the CFG_target_network_information.

+CFG_source_network_information+ is sent to the receiving DCP slave. It contains a port number. The receiving DCP slave waits for incoming data on this port number.

  Implementation hint: The sending port may be chosen randomly by the IP stack implementation. It is never checked in any way on the receiver side.

The following three tables complete the PDU descriptions of sections 3.3.7.19, 3.3.7.20, and 3.3.7.23, respectively, for IPv4-based transport protocols.

The IPv4-based transport protocol specific part of +CFG_target_network_information+ is defined by the following structure:

.CFG_target_network_information
[width="100%", cols="2,2,2,2" options="header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data type
|Field

|6
|6
|uint8
|transport_protocol

|7
|8
|uint16
|port

|9
|12
|uint32
|ip_address
|===

The IPv4-based transport protocol specific part of the corresponding +CFG_param_network_information+ is defined by the following structure:
 

.CFG_param_network_information
[width="100%", cols="2,2,2,2" options="header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data type
|Field

|6
|6
|uint8
|transport_protocol

|7
|8
|uint16
|port

|9
|12
|uint32
|ip_address
|===

The IPv4-based transport protocol specific part of +CFG_source_network_information+ is defined by the following structure:

.CFG_source_network_information
[width="100%", cols="2,2,2,2" options="header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data type
|Field

|6
|6
|uint8
|transport_protocol

|7
|8
|uint16
|port

|9
|12
|uint32
|ip_address
|===

---

===== Port information

If a port is specified inside the Control element (see section 5.11.2), Control PDUs may only be received over this port.

  Note: If no such port is specified, the integrator must obtain and set this information in another way, which is not specified in this document. The DCP slave provider might be consulted for clarification.

If a port or port range is specified inside the +DAT_input_output+ (see section 5.11.2) element, PDUs +DAT_input_output+ may only be received over these ports.

  Note: If no port or port range is specified inside the DAT_input_output element, the integrator must obtain and set this information in another way, which is not specified in this document. The DCP slave provider might be consulted for clarification.

If a port or port range is specified inside the +DAT_parameter+ element, PDUs +DAT_parameter+ may only be received over these ports.

  Note: If no port or port range is specified inside the DAT_parameter element, the integrator must obtain and set this information in another way, which is not specified in this document. The DCP slave provider might be consulted for clarification.

Some port numbers might already be used or reserved for dedicated services.

  Note: Implementation hint: If the master is free to choose a IPv4 port, he should use the free user ports specified by IANA organization. Otherwise it is possible that the chosen port collides with one of the ports reserved by IANA.

https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml

---

===== Host information

If a host is specified inside the Control element (see section 5.11.2) Control PDUs may only be received on this host.

  Note: If no host is specified, this can be interpreted as follows. The integrator must obtain and set this information in another way, which is not specified in this document.

If a host is specified inside the +DAT_input_output+ element PDUs +DAT_input_output+ may only be received on this host.

  Note: If no host is specified, this can be interpreted as follows. The integrator must obtain and set this information in another way, which is not specified in this document.

If a host is specified inside the +DAT_parameter+ element PDUs +DAT_parameter+ may only be received on this host.

Note: If no host is specified, this can be interpreted as follows. The integrator must obtain and set this information in another way, which is not specified in this document.

---

==== User Datagram Protocol (UDP/IPv4)
For UDP over IPv4 transport protocol, all specifications of section 4.2.1 apply. No further specifications are required.

---

==== Transmission Control Protocol (TCP/IPv4)

---

===== General
For TCP over IPv4 transport protocol, all specifications of section 4.2.1 apply. Furthermore, the following is required.

---

===== Length Prefix Framing
For TCP, length-prefix-framing is applied: Each PDU in the TCP stream must be preceded by a uint32 indicating the length of the PDU, excluding the length field itself.

---

=== Bluetooth Radio Frequency Communication (RFCOMM)

---

==== General
A DCP slave using Bluetooth is accessible through an address (BD_ADDR) and a port number. This information is defined within the DCP slave description. For communication with a DCP master, the DCP slave replies to the address and port where the initial +STC_register+ is coming from.

  Note: A DCP master could be implemented as a Bluetooth client, whereas a DCP slave could be implemented as a Bluetooth server.

The BD_ADDR is a unique and permanent 48-bit address number created in accordance with section 8.2 ("Universal addresses") of the IEEE 802-2014 [7].

---

==== Transport Protocol Specific Fields
The field port specifies a port number. +
The field +bd_addr+ specifies a Bluetooth device address.

  Implementation hint: The RFCOMM available ports are limited to a range between 1 and 30.

---

==== Network Information

The master distributes the communication information relevant for data exchange using the following two PDUs: +CFG_target_network_information+ is sent to the sending DCP slave. It contains the BD_ADDR and port number of the receiving DCP slave.

  Implementation hint: If multiple network information with the same data_id is received by a DCP slave, the DAT_input_output PDU is to be sent to all specified targets within the CFG_target_network_information.

+CFG_source_network_informatio+ is sent to the receiving DCP slave. It contains a port number. The receiving DCP slave listens on this port number for incoming data.

The following three tables complete the PDU descriptions of sections 3.3.7.19, 3.3.7.20, and 3.3.7.23, respectively, for Bluetooth RFCOMM.

The Bluetooth specific part of +CFG_target_network_information+ is defined by the following structure:

.CFG_target_network_information
[width="100%", cols="2,2,2,2", options="header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data type
|Field

|6
|6
|uint8
|transport_protocol

|7
|7
|uint8
|port

|8
|15
|uint64
|bd_addr
|===

The Bluetooth specific part of the corresponding +CFG_param_network_information+ is defined by the following structure:

.CFG_param_network_information
[width="100%", cols="2,2,2,2", options="header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data type
|Field

|6
|6
|uint8
|transport_protocol

|7
|8
|uint16
|port

|9
|12
|uint32
|bd_address
|===

The Bluetooth specific part of +CFG_source_network_information+ is defined by the following structure:

.CFG_source_network_information
[width="100%", cols="2,2,2,2", options="header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data type
|Field

|6
|6
|uint8
|transport_protocol

|7
|7
|uint8
|port

|8
|15
|uint64
|bd_addr
|===

---

==== Transport Protocol Specific PDU Fields

If a port is specified inside the Control element (see section 5.11.2), Control PDUs may only be received over this port.

  Note: If no such port is specified, this can be interpreted in two different ways. First, the integrator must obtain and set this information in another way, which is not specified in this document. Second, the DCP slave is not meant to be controlled via Bluetooth. The DCP slave provider might be consulted for clarification.

If a port or port range is specified inside the +DAT_input_output+ (see section 5.11.2) element, PDUs +DAT_input_output+ may only be received over these ports.

  Note: If no port or port range is specified inside the DAT_input_output element, this can be interpreted in three different ways. First, the integrator must obtain and set this information in another way, which is not specified in this document. Second, the DCP master is free to choose the port numbers. The DCP slave may reject the use of requested ports using PDU RSP_nack and the corresponding error code. Third, the DCP slave is not meant to exchange PDUs DAT_input_output using Bluetooth
RFCOMM. The DCP slave provider might be consulted for clarification.

If a port or port range is specified inside the +DAT_parameter+ element, PDUs +DAT_parameter+ may only be received over these ports.

  Note: If no port or port range is specified inside the DAT_parameter element, this can be interpreted in three different ways. First, the integrator must obtain and set this information in another way, which is not specified in this document. Second, the DCP master is free to choose the port numbers. The DCP slave may reject the use of requested ports using PDU RSP_nack PDU and the corresponding error code. Third, the DCP slave is not meant to exchange PDUs DAT_parameter using Bluetooth RFCOMM. The DCP slave provider might be consulted for clarification.

Some port numbers might already be used or reserved for dedicated services.

---

===== Endpoint Address
The field +endpoint_address+ is used to specify an endpoint address.

---

==== Descriptors
The following sections describe the applied USB Descriptors used for the DCP USB class. The device and configuration descriptor are vendor specific. There must be at least one Interface descriptor for the DCP containing a DCP Descriptor, as well as the endpoint descriptors used for the DCP slave.

---

===== Interface
.Interface descriptor
[width="100%", cols="2,2,2,3,3" options="header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data-type
|Field Name
|Value

|0
|0
|uint8
|bLength
|9

|1
|1
|uint8
|bDescriptorType
|4

|2
|2
|uint8
|bInterfaceNumber
|Vendor Specific

|3
|3
|uint8
|bAlternateSetting
|Vendor Specific

|4
|4
|uint8
|bNumEndpoints
|Vendor Specific

|5
|5
|uint8
|bInterfaceClass
|255^2^ footnote:[Implementation Hint: Because an official USB class for DCP does not exist at the moment, the vendor specific class is used. Therefore 205 is selected as an arbitrary number to define the subclass and protocol.]


|6
|6
|uint8
|bInterfaceSubClass
|205^2^

|7
|7
|uint8
|bInterfaceProtocol
|205^2^

|8
|8
|uint8
|iInterface
|Vendor Specific
|===


.DCP descriptor
[width="100%", cols="2,2,2,3,3" options="header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data-type
|Field Name
|Value

|0
|0
|uint8
|bLength
|9

|1
|1
|uint8
|bDescriptorType
|4

|2
|18
|byte[]
|slave_uuid
|Vendor Specific
|===

---

===== Endpoint
.Request pipe
[width="100%", cols="2,2,2,3,3" options="header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data-type
|Field Name
|Value

|0
|0
|uint8
|bLength
|7

|1
|1
|uint8
|bDescriptorType
|5

|2
|2
|uint8
|bEndpointAddress
|16 (00010000~Bin~)

|3
|3
|uint8
|bmAttributes
|3 (00000011~Bin~)

|4
|5
|uint16
|wMaxPacketSize
|1024

|6
|6
|uint8
|bInterval
|16

|===


.Response-notification pipe
[width="100%", cols="2,2,2,3,3" options="header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data-type
|Field Name
|Value

|0
|0
|uint8
|bLength
|7

|1
|1
|uint8
|bDescriptorType
|5

|2
|2
|uint8
|bEndpointAddress
|16 (00010000~Bin~)

|3
|3
|uint8
|bmAttributes
|3 (00000011~Bin~)

|4
|5
|uint16
|wMaxPacketSize
|1024

|6
|6
|uint8
|bInterval
|16

|===

.Data-out pipe
[width="100%", cols="2,2,2,3,3" options="header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data-type
|Field Name
|Value

|0
|0
|uint8
|bLength
|7

|1
|1
|uint8
|bDescriptorType
|5

|2
|2
|uint8
|bEndpointAddress
|Vendor Specific ^3^footnote:[Must be constructed according to the USB standard. The endpoint number must be greater than 2. The direction must be 0 (Out).]

|3
|3
|uint8
|bmAttributes
|Vendor Specific ^4^footnote:[Must be constructed according to the USB standard. The transfer type must be Isochronous or Interrupt. ]

|4
|5
|uint16
|wMaxPacketSize
|1024

|6
|6
|uint8
|bInterval
|Vendor Specific
|===




.Data-in pipe
[width="100%", cols="2,2,2,3,3" options="header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data-type
|Field Name
|Value

|0
|0
|uint8
|bLength
|7

|1
|1
|uint8
|bDescriptorType
|5

|2
|2
|uint8
|bEndpointAddress
|Vendor Specific ^5^ footnote:[Must be constructed according to the USB standard. The endpoint number must be greater than 2. The direction must be 1 (In).]

|3
|3
|uint8
|bmAttributes
|Vendor Specific ^6^ footnote:[Must be constructed according to the USB standard. The transfer type must be Isochronous or Interrupt.]

|4
|5
|uint16
|wMaxPacketSize
|1024

|6
|6
|uint8
|bInterval
|Vendor Specific
|===

---

==== Network Information

.CFG_target_network_information
The USB specific part of +CFG_target_network_information+ is defined by the following structure:
[width="100%", cols="2,2,2,2", options= "header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data type
|Field

|6
|6
|uint8
|transport_protocol = 0x5

|7
|7
|uint8
|endpoint_address

|8
|23
|byte[16]
|slave_uuid
|===
The USB specific part of +CFG_source_network_information+ is defined by the following structure:

.CFG_source_network_information
[width="100%", cols="2,2,2,2", options= "header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data type
|Field

|6
|6
|uint8
|transport_protocol = 0x5

|7
|7
|uint8
|endpoint_address
|===

The USB specific part of +CFG_param_network_information+ is defined by the following structure:
 
.CFG_param_network_information
[width="100%", cols="2,2,2,2", options= "header"]
|===
|First Position [Byte]
|Last Position [Byte]
|Data type
|Field

|6
|6
|uint8
|transport_protocol = 0x5

|7
|7
|uint8
|endpoint_address
|===

---

==== DAT_input_output forwarding
According to the USB standard communication is only possible between USB host and USB device. The USB host driver must forward the +DAT_input_output+ PDU to the corresponding USB device for slave-to-slave communication.

---

=== CAN Bus Communication Systems
This specification supports CAN bus communication systems. Due to the facts that

*	the CAN payload is limited to 8 bytes,
*	CAN does not support fragmentation,
*	CAN uses its own addressing schema (arbitration)
* and thus not all Control PDUs can be sent via CAN as defined in native DCP specification
the DCP specification for CAN bus is non-native. This specification of DCP over CAN supports the KCD file formatfootnote:[https://github.com/dschanoeh/Kayak]

In order to map the DCP onto the CAN bus, two additional resources are provided together with this specification:

*	DCP over CAN XSD schema description (DCP_over_CAN.xsd)
*	DCP over CAN XSL style sheet (DCP_over_CAN_to_KCD.xsl)

---

==== Procedure
The intended procedure is to use the XSD schema to create a configuration in XML file format. An XSL style sheet is then applied to this XML file, generating a valid KCD file.

---

==== DCP over CAN
Figure 8 shows the DCP over CAN root element.

.DcpOverCAN root element
image::C:\Users\damianlang\Desktop\Atom\DCP\Adoc\DCP_2.0\DcpOverCan root element.png[align="center"]

.DcpOverCan element
[width="100%", cols="2,4", options="header"]
|===
|Element name
|Description

|KMatrix
|Contains all elements to describe the messages & signals of the CAN bus and the participation of the bus members to the messages.

|ScenarioConfiguration
|Contains all elements to describe the co-simulation scenario, which would be distributed over configuration PDUs in a native DCP transport protocol for each DCP slave. In addition it contains the name, DCP id & uuid. Which element belongs to which DCP slave can be determined using the uuid.
|===

---

==== Definition of KMatrix
The element +KMatrix+ is specified as follows. The +KMatrix+ element consist optional of the +CAN+ message description all state change, information, notification & response PDUs , as well as an arbitrary number of +CAN+ messages for +DAT_input_output+ & +DAT_parameter+ PDUs. Each state change, information, notification or response PDU is defined in the following way.

.KMatrix element attributes

image::C:\Users\damianlang\Desktop\Atom\DCP\Adoc\DCP_2.0\DcpOverCanKMatr_ixAttributes.png[align="center"]

.KMatrix element attributes
[width="100%", cols="1,3", options="header"]
|===
|Attribute name
|Description

|f_<field_name>_data_type
|The data type of the field <field_name> as integer (see 3.1.10 for corresponding data type).

|f_<field_name>_endianness
|The endianness of the field <field_name>. “little” means little endian, “big” means big endian.
|===

.Attributes of every state change, information, notification & response PDU
[width="100%", cols="1,3", options="header"]
|===
|Attribute name
|Description

|canId
|The CAN identifier in the header of the CAN message

|senderRef
|The DCP id of the sending DCP slave. For state change & information PDUs this is fix, because only the master (DCP id = 0) can send this PDU.

|length
|The length of the CAN payload field.

|f_<field_name>
|The starting byte of <field_name> in the CAN payload. “H” means that this field is not contained in the CAN payload and its value can be determined by the CAN identifier in the header.
|===

.STC_register PDU
image::C:\Users\damianlang\Desktop\Atom\DCP\Adoc\DCP_2.0\DcpOverCan STC_register.png[align="center"]

The element +DAT_input_output+ consists of up to eight Payload and up to 254 Receiver ele-ments. It is defined as follows:

.DAT_input_output element
image::C:\Users\damianlang\Desktop\Atom\DCP\Adoc\DCP_2.0\DcpOverCan_DAT_input_output.PNG[align="center"]


.DAT_input_output element attributes
[width="100%", cols="1,3", options="header"]
|===
|Attribute name
|Description

|canId
|The CAN identifier in the header of the CAN message.

|senderRef
|The DCP id of the sending DCP slave.

|dataId
|The data id of the DAT_input_output PDU.

|length
|The length of the CAN payload field.

|f_<field_name>
|The starting byte of <field_name> in the CAN payload. “H” means that this field is not contained in the CAN payload and its value can be determined by the CAN identifier in the header.

|dcpId
|The DCP id of the DCP slave which receives this CAN message.
|===

In +DAT_input_output+, the +Payload+ element contains the definition of one output from the send-ing DCP slave. The choice of the Payload element defines the data type of the output. Payload is defined as follows:

.Payload element
image::C:\Users\damianlang\Desktop\Atom\DCP\Adoc\DCP_2.0\DcpOverCan payload.PNG[align="center"]

.Payload element attributes
[width="100%", cols="1,3", options="header"]
|===
|Attribute name
|Description

|name
|The name of the output.

|offset
|The starting byte of the output in the CAN payload. +
Note: This is not equal to the position in the CFG_output PDU.

|unit
|The unit of the send output.

|min
|The minimum of the output

|max
|The maximum of the output.

|endianness
|The endianness of the output. “little” means little endian, “big” means big endian.
|===

The element +DAT_parameter+ consists of up to eight Payload and up to 254 receiver elements. It is defined as follows.

.DAT_input_output element
image::C:\Users\damianlang\Desktop\Atom\DCP\Adoc\DCP_2.0\DcpOverCan_DAT_input_output.PNG[align="center"]


.Attributes of DAT_parameter
[width="100%", cols="1,3", options="header"]
|===
|Attribute name
|Description

|canId
|The CAN identifier in the header of the CAN message.

|senderRef
|The DCP id of the sending DCP slave.

|paramId
|The parameter id of the DAT_parameter PDU.

|length
|The length of the CAN payload field.

|f_<field_name>
|The starting byte of <field_name> in the CAN payload. “H” means that this field is not contained in the CAN payload and its value can be determined by the CAN identifier in the header.

|dcpId
|The DCP id of the DCP slave which receives this CAN message.

|===

---

==== Definition of the Scenario Configuration
The element +ScenarioConfiguration+ is defined as follows:

.ScenarioConfiguration element
image::C:\Users\damianlang\Desktop\Atom\DCP\Adoc\DCP_2.0\DcpOverCan scenario configuration.PNG[align="center"]

.Attributes of ScenarioConfiguration and subsequent elements
[width="100%", cols="1,3", options="header"]
|===
|Attribute name
|Description

|name
|The name of the DCP slave.

|uuid
|The uuid of the DCP slave.

|dcpId
|The DCP id of the DCP slave.

|All other attributes
|See section 3.4 for further description.
|===
