===== Variable Naming Convention
Within the DCP slave description the attribute +variableNamingConvention+ of element +dcpDescription+ defines the convention how the variable names are constructed. This information may then be used by the simulation environment for structuring.
Possible options are given in Table 10.

  Note: This is based on FMI 2.0.

.Variable naming convention options
[width="100%", cols="3,3", options="header", float="center" ]
|===
|Option
|Description

|flat
|name = Unicode-char { Unicode-char } +
Unicode-char = any Unicode character without carriage return (0x0D), line feed (0x0A) nor tab (0x09)

This definition is identical to +xs:normalizedString+ used in the specification of FMI. +
The names shall be unique, non-empty strings are not allowed.

|structured
|Structured names are hierarchically organized and use “.” as a separator between hierarchies. A name consists of “_”, letters and digits or may consist of any characters enclosed in single apostrophes. A name may identify an array element on every hierarchical level using square brackets “[...]” to identify the respective array index.

In the following definitions, an extended Backus-Naur form (EBNF) [4] is used.

The precise syntax is:
name = identifier {vbar} "der(" identifier ["," unsignedInteger] ")"
identifier = B-name [ arrayIndices ] {"." B-name [ arrayIndices ] }
B-name = nondigit{digit{vbar}nondigit}{vbar}Q-name
nondigit = "_" {vbar} letters "a" to "z" {vbar} letters "A" to "Z"
digit = "0" {vbar} "1" {vbar} "2" {vbar} "3" {vbar} "4" {vbar} "5" {vbar} "6" {vbar} "7" {vbar} "8" {vbar} "9"
Q-name = "’" ( Q-char {vbar} escape ) { Q-char {vbar} escape } "’"
Q-char = nondigit {vbar} digit {vbar} "!" {vbar} "#" {vbar} "$" {vbar} "%" {vbar} "&" {vbar} "(" {vbar} ")" {vbar} "*" {vbar} "+" {vbar} "," {vbar} "-" {vbar} "." {vbar} "/" {vbar} ":" {vbar} ";" {vbar} "<" {vbar} ">" {vbar} "=" {vbar} "?" {vbar} "@" {vbar} "[" {vbar} "]" {vbar} "^" {vbar} "{" {vbar} "}" {vbar} "{vbar}" {vbar} "~" {vbar} " "
escape = "\’" {vbar} "\"" {vbar} "\?" {vbar} "\\" {vbar} "\a" {vbar} "\b" {vbar}
"\f" {vbar} "\n" {vbar} "\r" {vbar} "\t" {vbar} "\v"
arrayIndices = "[" unsignedInteger {"," unsignedInteger} "]"
unsignedInteger = digit { digit }

Note: This definition is identical to the syntax of an identifier in Modelica version 3.2.

The tree of names must be mapped to an ordered list of structured variable names in depth-first order.

Example:
vehicle +
    transmission +
        ratio +
        outputSpeed +
    engine +
        inputSpeed +
        temperature

is mapped to the following list of structured variable names:

vehicle.transmission.ratio +
vehicle.transmission.outputSpeed +
vehicle.engine.inputSpeed +
vehicle.engine.temperature

Note: No further restrictions apply (e.g., no alphabetical sort on same hierarchical level)

Variables representing array elements must be given in a consecutive sequence. Elements of multi-dimensional arrays are ordered according to row major order, that is elements of the last index are given in sequence.

For example, elements of the vector “centerOfMass” in body “arm1”  of robot are mapped to the following variables:

robot.arm1.centerOfMass[1] +
robot.arm1.centerOfMass[2] +
robot.arm1.centerOfMass[3]

For example, a table T[4,3,2] (first dimension 4 entries, second dimension 3 entries, third dimension 2 entries) is mapped to the following Variables:

T[1,1,1] +
T[1,1,2] +
T[1,2,1] +
T[1,2,2] +
T[1,3,1] +
T[1,3,2] +
T[2,1,1] +
T[2,1,2] +
T[2,3,1] +
…

It might occur that not all elements of an array are present. If they are present, they are given in consecutive order in the DCP slave description.

|===
